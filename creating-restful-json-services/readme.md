## Conventions

When writing a Node.js service it is typical to default to listening on a well-known port (say 3000) while also allowing that port to be overridden with the PORT environment variable. This can be accessed with process.env.PORT and then passed to a servers listen method.

The npm init fastify command which generates a Fastify project uses fastify-cli to start the application, which automatically allows the PORT environment variable to specify the port.

The express command-line executable that's installed by the express-generator module when globally installed generates a bin/www file that similarly allows the port to be specified via a PORT environment variable.

Another frequently occurring convention that is important to the deployment of Node.js services is a standard approach to starting the Node.js process. The standard approach is to have a start field in the scripts object of the package.json file so that the process can be started with npm start. The npm start command will execute the contents of the start field as a shell command.

Another frequently occurring convention that is important to the deployment of Node.js services is a standard approach to starting the Node.js process. The standard approach is to have a start field in the scripts object of the package.json file so that the process can be started with npm start. The npm start command will execute the contents of the start field as a shell command.

For instance in Express the start field would usually be:

```sh
"scripts": {
  "start": "node ./bin/www"
}
```

In Fastify the --integrate flag can be executed in a directory with a package.json file to generate a project and also update the preexisting package.json file:

```sh
npm init fastify --integrate
```

In this case the start field in the scripts object will be updated automatically and all the usual files (such as app.js, the routes folder and so on) will be added into that directory:

<p align="center">
  <img src="https://raw.githubusercontent.com/jsricarde/jsnsd-labs/main/creating-restful-json-services/imgs/json-1.png" width="1000" />
  <br />
</p>

In the following sections we'll be using Fastify to implement a RESTful JSON service.

## Implementing a RESTful JSON GET with Fastify

REST stands for REpresentational State Transfer, and it's an architectural style that seeks to make the most of the features of HTTP/1.1. Data is communicated via HTTP response bodies, metadata is communicated through HTTP headers, and operation outcomes are communicated with HTTP status codes. The State Transfer part of REST is about shuffling state from clients to server-backends. A REST service should be stateless, an intermediate layer between a browser and a database and it should boil down to performing one or more CRUD operations (Create, Read, Update, Delete).

In this section we'll focus on implementing a Read, which maps to the HTTP GET method.

Let's create a folder called my-service and make it our current working directory:

```sh
node -e "fs.mkdirSync('my-service')"
cd my-service
```

Now let's generate a new Fastify project:

```sh
npm init fastify
```

Once the project is generated we need to install dependencies and also add fastify-sensible:

```sh
npm install
npm install fastify-sensible
```

The fastify-sensible plugin adds some useful "sane defaults" to Fastify, including the convenience functions for HTTP status codes and messages. We need to register this plugin in the app.js file that will have been generated by the npm init fastify command. The app.js file should look as follows:

```sh
'use strict'

const path = require('path')
const AutoLoad = require('fastify-autoload')
const sensible = require('fastify-sensible')

module.exports = async function (fastify, opts) {

  fastify.register(sensible)

  fastify.register(AutoLoad, {
    dir: path.join(__dirname, 'plugins'),
    options: Object.assign({}, opts)
  })

  fastify.register(AutoLoad, {
    dir: path.join(__dirname, 'routes'),
    options: Object.assign({}, opts)
  })
}
```

A fairly typical situation would be to integrate with some kind of database such as MariaDB, Redis, Postgres, MongoDB and so forth. In every case the service is reading data from an external data source. In our case we're going to contrive a model that conceptually plays the role of a database but that stores state in-process. It's important to acknowledge that this actually violates the Statelessness constraint of REST, in that state shouldn't be held in the process that handles the HTTP request. However the model we'll create is a placeholder for teaching purposes that should be thought of in an abstract sense as a database connection.

Let's create a file which we'll call `model.js`:

```sh
node -e "fs.openSync('model.js', 'w')"
```

The contents of `model.js` should be as follows:

```sh
'use strict'

module.exports = {
  bicycle: bicycleModel()
}

function bicycleModel () {
  const db = {
    1: { brand: 'Veloretti', color: 'green' },
    2: { brand: 'Batavus', color: 'yellow' }
  }

  return {
    read
  }

  function read (id, cb) {
    if (!(db.hasOwnProperty(id))) {
      const err = Error('not found')
      setImmediate(() => cb(err))
      return
    }
    setImmediate(() => cb(null, db[id]))
  }
}
```

Not only is the code in model.js contrived, the error handling is subpar. Ideally there would be a code property on the errors and a map of error constants to check against. However the point here is to emulate more real-world scenarios where integrating with libraries can be messy and less than ideal. Note that the read function uses setImmediate this is to simulate asynchronous operations. I/O operations should always be asynchronous when dealing with requests.

Our GET route must:

- Respond with a valid JSON payload.
- Respond with an application/json Content-Type header.
- Respond with 200 status code when successful.
- Respond with a 404 status when a requested resource is not available. This would be when the read function in model.js responds with an error with message 'not found'.
- Respond with a 400, 404 or 405 for unsupported methods. For instance a POST to our server should respond with one of these codes, it doesn't matter which as the specification is ambiguous on these points and it can come down to implementation goals or wider policy.
- Respond with a 500 status for unknown errors.

### Our logic

Let's create a route called `bicycle`. In Fastify all we need to do is create a directory in routes called bicycle and place an index.js file in it:

```sh
cd routes
node -e "fs.mkdirSync('bicycle')"
cd bicycle
node -e "fs.openSync('index.js', 'w')"
cd ..
cd ..
```

The fact that the API we need to work with is callback-based gives us an opportunity to explore the various ways to integrate with callback-based API's (as opposed to promise-based) in Fastify.

While the response can be returned from an async function (which is to say, a promise can be returned which resolves to the response), the reply.send method can be used in a callback-based approach instead.

Let's make our routes/bicycle/index.js file look as follows:

```sh
'use strict'

const { bicycle } = require('../../model')

module.exports = async (fastify, opts) => {
  fastify.get('/:id', (request, reply) => {
    const { id } = request.params
    bicycle.read(id, (err, result) => {
      if (err) {
        if (err.message === 'not found') reply.notFound()
        else reply.send(err)
      } else reply.send(result)
    })
  })
}
```

Now, if we start our server (npm start or npm run dev) and navigate to http://localhost:3000/bicycle/1 in the browser we should see the data output:

```sh
{"brand":"Veloretti","color":"green"}
```

However, if we navigate to http://localhost:3000/bicycle/3 we should see:

```sh
{"statusCode":404,"error":"Not Found","message":"Not Found"}
```

If we wanted to use a callback API inside an async route handler the following approach could instead be taken. Let's modify routes/bicycle/index.js to the following:

```sh
'use strict'

const { bicycle } = require('../../model')

module.exports = async (fastify, opts) => {
  fastify.get('/:id', async (request, reply) => {
    const { id } = request.params
    bicycle.read(id, (err, result) => {
      if (err) {
        if (err.message === 'not found') reply.notFound()
        else reply.send(err)
      } else reply.send(result)
    })
    await reply
  })
}
```

This can be a useful approach when mixing callback-based API's and promise-based API's in a route handler. If the await reply line is removed it results in an error message.

The other approach to using callback-based APIs in an async function is to promisify the API.

Let's wrap up by altering index.js again to look as follows:

```sh
'use strict'
const { promisify } = require('util')
const { bicycle } = require('../../model')
const read = promisify(bicycle.read)

module.exports = async (fastify, opts) => {
  const { notFound } = fastify.httpErrors

  fastify.get('/:id', async (request, reply) => {
    const { id } = request.params
    try {
      return await read(id)
    } catch (err) {
      if (err.message === 'not found') throw notFound()
      throw err
    }
  })
}
```